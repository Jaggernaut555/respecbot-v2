package db

import (
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/Jaggernaut555/respecbot-v2/logging"
	"github.com/Jaggernaut555/respecbot-v2/types"
	"github.com/jinzhu/gorm"
	// Needed by gorm
	_ "github.com/jinzhu/gorm/dialects/sqlite"
	"github.com/shibukawa/configdir"
)

const (
	projectName = "respecbot-v2"
	vendorName  = "Jaggernaut555"
)

var db *gorm.DB
var fileDir *configdir.Config
var dbFile string

// Setup Create a directory in userdata to store the database file and any other files generated by this program
func Setup(dbFileName string) error {
	var err error

	configDir := configdir.New(vendorName, projectName)
	fileDir = configDir.QueryCacheFolder()

	dbFile = filepath.FromSlash(fileDir.Path + "/" + dbFileName)

	if err = fileDir.MkdirAll(); err != nil {
		return err
	}

	if !fileDir.Exists(dbFileName) {
		if _, err = fileDir.Create(dbFileName); err != nil {
			return err
		}
	}

	db, err = gorm.Open("sqlite3", dbFile)
	if err != nil {
		return err
	}
	logging.Log("SQLite file setup at", dbFile)

	createTables(db)

	//db.LogMode(true)

	return err
}

// DeleteDB Delete the database file specified by the given name
func DeleteDB(dbFileName string) error {
	configDir := configdir.New(vendorName, projectName)
	fileDir = configDir.QueryCacheFolder()
	dbFile = filepath.FromSlash(fileDir.Path + "/" + dbFileName)
	logging.Log(fmt.Sprintf("Deleting %v", dbFile))
	return os.Remove(dbFile)
}

// Purge Delete all files related to this app in the userdata directory
func Purge() error {
	configDir := configdir.New(vendorName, projectName)
	fileDir = configDir.QueryCacheFolder()
	logging.Log(fmt.Sprintf("Deleting %v", fileDir.Path))
	return os.RemoveAll(fileDir.Path)
}

func createTables(d *gorm.DB) {
	if !d.HasTable(&types.User{}) {
		d.CreateTable(&types.User{})
	}
	if !d.HasTable(&types.Channel{}) {
		d.CreateTable(&types.Channel{})
	}
	if !d.HasTable(&types.Server{}) {
		d.CreateTable(&types.Server{})
	}
	if !d.HasTable(&types.Message{}) {
		d.CreateTable(&types.Message{})
	}
	if !d.HasTable(&types.Respec{}) {
		d.CreateTable(&types.Respec{})
	}
}

// GetTotalRespec Gets the total positive respec in every server combined
func GetTotalRespec() int {
	var total []types.Respec
	db.Model(&types.Respec{}).Where("respec > 0").Select("sum(respec) as respec").Scan(&total)
	if len(total) < 1 {
		return 0
	}
	return total[0].Respec
}

// GetTotalServerRespec Gets the total positive respec in the given server
func GetTotalServerRespec(server *types.Server) int {
	var total []types.Respec
	db.Model(&types.Respec{}).Preload("Channel.Server").Where("respec > 0 AND channel_key IN (?)", db.Table("channels").Select("key").Where("server_key = ?", server.Key).QueryExpr()).Select("sum(respec) as respec").Scan(&total)
	if len(total) < 1 {
		return 0
	}
	return total[0].Respec
}

// GetServerRespecCap Gets the soft respec cap in the given server (max of (7/16 of total respec) or (100))
func GetServerRespecCap(server *types.Server) int {
	var respec = GetTotalServerRespec(server)
	if respec*7/16 < 100 {
		return 100
	}
	return respec * 7 / 16
}

// GetServerUsers Gets a list of all users in the given server from the database
func GetServerUsers(server *types.Server) []*types.User {
	var users []*types.User
	var respec []*types.Respec
	respec = GetServerRespec(server)
	for _, v := range respec {
		users = append(users, v.User)
	}
	return users
}

// GetGlobalUsers Gets a list of all users from the database
func GetGlobalUsers() []*types.User {
	var users []*types.User
	if err := db.Find(&users).Error; err != nil {
		return nil
	}
	return users
}

// GetLocalRespec Gets the respec of every user in the given channel
func GetLocalRespec(channel *types.Channel) []*types.Respec {
	var respec []*types.Respec
	if err := db.Preload("User").Preload("Channel").Preload("Channel.Server").Order("respec DESC").Where("channel_key = ?", channel.Key).Find(&respec).Error; err != nil {
		return nil
	}
	return respec
}

// GetServerRespec Gets the respec of every user in the given server
func GetServerRespec(server *types.Server) []*types.Respec {
	var respec []*types.Respec
	if err := db.Preload("User").Preload("Channel").Preload("Channel.Server").Group("user_key").Order("respec DESC").Select("key, user_key,channel_key,updated_at, sum(respec) as respec").Where("channel_key IN (?)", db.Table("channels").Where("server_key = ?", server.Key).Select("key").QueryExpr()).Find(&respec).Error; err != nil {
		return nil
	}
	return respec
}

// GetGlobalRespec Gets the respec of every user in every server
func GetGlobalRespec() []*types.Respec {
	var respec []*types.Respec
	if err := db.Preload("User").Preload("Channel").Preload("Channel.Server").Group("user_key").Order("respec DESC").Select("key, user_key,channel_key,updated_at, sum(respec) as respec").Find(&respec).Error; err != nil {
		return nil
	}
	return respec
}

// GetUserLocalRespec Gets the total respec of a given user in the given channel
func GetUserLocalRespec(user *types.User, channel *types.Channel) int {
	var respec types.Respec
	if err := db.Where("user_key = ? AND channel_key = ?", user.Key, channel.Key).First(&respec).Error; err != nil {
		return 0
	}
	return respec.Respec
}

// GetUserServerRespec Gets the total respec of a given user in the given server
func GetUserServerRespec(user *types.User, server *types.Server) int {
	var respec []*types.Respec
	if err := db.Group("user_key").Select("user_key, sum(respec) as respec").Where("user_key = ? AND channel_key IN (?)", user.Key, db.Table("channels").Select("key").Where("server_key = ?", server.Key).QueryExpr()).Find(&respec).Error; err != nil {
		return 0
	}
	return respec[0].Respec
}

// GetLastRespecTime Get's the time.Time of the last time a given users respec was updated in the given channel
func GetLastRespecTime(user *types.User, channel *types.Channel) *time.Time {
	var respec types.Respec
	if err := db.Where("user_key = ? AND channel_key = ?", user.Key, channel.Key).First(&respec).Error; err != nil {
		return nil
	}
	return &respec.UpdatedAt
}

// AddRespec Updates the respec in the database
func AddRespec(respec *types.Respec) {
	db.Where(types.Respec{UserKey: respec.User.Key, ChannelKey: respec.Channel.Key}).Assign(types.Respec{Respec: respec.Respec}).FirstOrCreate(respec)
}

// GetServerTopUser Gets the top user in the given server
func GetServerTopUser(server *types.Server) *types.User {
	var respec types.Respec
	if err := db.Preload("User").Group("user_key").Order("respec DESC").Select("user_key, sum(respec) as respec").Where("channel_key IN (?)", db.Table("channels").Select("key").Where("server_key = ?", server.Key).QueryExpr()).First(&respec).Error; err != nil {
		return nil
	}
	return respec.User
}

// GetServerRulingClass Gets a list of users who hold the top 50% of respec in the given server
func GetServerRulingClass(server *types.Server) []*types.User {
	var users []*types.User
	if err := db.Where("key in (?)", db.Table("respecs").Select("user_key").Where("channel_key IN (?)", db.Table("channels").Select("key").Where("server_key = ?", server.Key).QueryExpr()).Group("user_key").Having("sum(respec) > (?)", db.Raw("Select avg(sums) FROM (?) WHERE sums > 0", db.Table("respecs").Select("sum(respec) as sums").Group("user_key").Where("channel_key IN (?)", db.Table("channels").Select("key").Where("server_key = ?", server.Key).QueryExpr()).QueryExpr()).QueryExpr()).QueryExpr()).Find(&users).Error; err != nil {
		return nil
	}
	return users
}

// GetServerLosers Get a list of users with a negative score in the given server
func GetServerLosers(server *types.Server) []*types.User {
	var users []*types.User
	if err := db.Where("key in (?)", db.Table("respecs").Select("user_key").Where("channel_key IN (?)", db.Table("channels").Select("key").Where("server_key = ?", server.Key).QueryExpr()).Group("user_key").Having("sum(respec) < (0)").QueryExpr()).Find(&users).Error; err != nil {
		return nil
	}
	return users
}

// GetLocalStats Gets a list of users and their scores in the given channel
func GetLocalStats(channel *types.Channel) types.PairList {
	var pairs types.PairList
	var respec []*types.Respec
	respec = GetLocalRespec(channel)
	if respec == nil {
		return nil
	}

	for _, v := range respec {
		pairs = append(pairs, types.Pair{Key: v.User.Name, Value: v.Respec})
	}

	return pairs
}

// GetServerStats Gets a list of users and their scores in the given server
func GetServerStats(server *types.Server) types.PairList {
	var pairs types.PairList
	var respec []*types.Respec
	respec = GetServerRespec(server)
	if respec == nil {
		return nil
	}

	for _, v := range respec {
		pairs = append(pairs, types.Pair{Key: v.User.Name, Value: v.Respec})
	}

	return pairs
}

// GetGlobalStats Gets a list of users and their scores in all servers and channels
func GetGlobalStats() types.PairList {
	var pairs types.PairList
	var respec []*types.Respec
	respec = GetGlobalRespec()
	if respec == nil {
		return nil
	}

	for _, v := range respec {
		pairs = append(pairs, types.Pair{Key: v.User.Name, Value: v.Respec})
	}

	return pairs
}

// NewUser Insert the user into the database. Fills the 'Key' field'
func NewUser(user *types.User) error {
	if user.APIID == "" {
		return fmt.Errorf("APIID not set")
	}
	if user.Name == "" {
		return fmt.Errorf("Name not set")
	}
	if user.ID == "" {
		return fmt.Errorf("ID not set")
	}
	if user.Key != 0 {
		return fmt.Errorf("Key already set")
	}
	if user.Bot {
		return fmt.Errorf("Cannot add bot user")
	}
	if db.NewRecord(user) {
		db.Create(user)
	}
	return nil
}

// GetUser Get the user identified by their user ID in the given API
func GetUser(UserID, APIID string) *types.User {
	var user types.User
	if err := db.Where("id = ? AND api_id = ?", UserID, APIID).First(&user).Error; err != nil {
		return nil
	}
	return &user
}

// NewChannel Insert the channel into the database. Fills the 'Key' field
func NewChannel(channel *types.Channel) {
	if db.NewRecord(channel) {
		db.Create(channel)
	}
}

// GetChannel Get the channel identified by the channel ID in the given API
func GetChannel(channelID, APIID string) *types.Channel {
	var channel types.Channel
	if err := db.Preload("Server").Where("id = ? AND api_id = ?", channelID, APIID).First(&channel).Error; err != nil {
		return nil
	}
	return &channel
}

// GetLoggingChannels returns a list of Channels that receive logging
func GetLoggingChannels(server *types.Server) *[]types.Channel {
	var channels []types.Channel

	if err := db.Where("server_key = ? AND log_active = ?", server.Key, 1).Find(&channels).Error; err != nil {
		return &[]types.Channel{}
	}

	return &channels
}

// UpdateChannel Updates and channel information to the stored channel in database
func UpdateChannel(channel *types.Channel) {
	db.Model(&channel).Update("active", channel.Active)
}

// UpdateLogChannel sets whether or not the Channel receives log messages
func UpdateLogChannel(channel *types.Channel) {
	db.Model(&channel).Update("log_active", channel.LogActive)
}

// NewServer Insert the server into the database. Fills the 'Key' field
func NewServer(server *types.Server) {
	if db.NewRecord(server) {
		db.Create(server)
	}
}

// GetServer Get the server identified by the serverID in the given API
func GetServer(serverID, APIID string) *types.Server {
	var server types.Server
	if err := db.Where("id = ? AND api_id = ?", serverID, APIID).First(&server).Error; err != nil {
		return nil
	}
	return &server
}

// NewMessage Insert the given message into the database. Fills the 'Key' field
func NewMessage(message *types.Message) {
	if db.NewRecord(message) {
		db.Create(message)
	}
}

// GetLastMessage Get the last message by the given user posted in the given channel
func GetLastMessage(user *types.User, channel *types.Channel) *types.Message {
	var message types.Message
	if err := db.Preload("Channel").Preload("Channel.Server").Preload("Author").Where("user_key = ? AND channel_key = ?", user.Key, channel.Key).Order("time DESC").First(&message).Error; err != nil {
		return nil
	}
	return &message
}

// GetUserLastMessages Get the last 'amount' messages by the given user posted in the given channel
func GetUserLastMessages(user *types.User, channel *types.Channel, amount int) []*types.Message {
	var messages []*types.Message
	if err := db.Preload("Channel").Preload("Channel.Server").Preload("Author").Where("user_key = ? AND channel_key = ?", user.Key, channel.Key).Order("time DESC").Limit(amount).Find(&messages).Error; err != nil {
		return nil
	}
	return messages
}

// GetChannelLastMessage Get the last message posted in the given channel
func GetChannelLastMessage(channel *types.Channel) *types.Message {
	var message types.Message
	if err := db.Preload("Channel").Preload("Channel.Server").Preload("Author").Where("channel_key = ?", channel.Key).Order("time DESC").First(&message).Error; err != nil {
		return nil
	}
	return &message
}

// IsMessageUnique Check if the author of the given message has posted the same thing in their last 25 posts
func IsMessageUnique(message *types.Message) bool {
	var count int
	if err := db.Model(&types.Message{}).Table("messages a").Joins("INNER JOIN (?) as y ON a.key = y.key", db.Table("messages c").Select("c.key").Where("c.channel_key = ? AND c.user_key = ?", message.Channel.Key, message.Author.Key).Order("time DESC").Limit(25).QueryExpr()).Where("a.content LIKE ?", message.Content).Count(&count).Error; err != nil || count == 0 {
		return true
	}
	return false
}

// IsMultiPosting Check if the last 3 posts in the channel are by the author of the given message
func IsMultiPosting(message *types.Message) bool {
	var count int
	if err := db.Table("messages a").Joins("INNER JOIN (?) as x ON a.key = x.key", db.Table("messages b").Select("b.key").Where("b.channel_key = ?", message.ChannelKey).Order("time DESC").Limit(3).QueryExpr()).Where("a.user_key = ?", message.Author.Key).Count(&count).Error; err != nil || count != 3 {
		return false
	}
	return true
}
